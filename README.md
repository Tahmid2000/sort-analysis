To properly analyze each of the 7 sorts, I focused on total runtime, comparisons, and movements. Out of these three though, I focused the most on total runtime. The most challenging part of all this was to calculate the number of comparisons and movements/swaps because different sorts compared and swapped very differently. For that reason, I mainly compared the sorts based on time because the way to calculate time was consistent amongst the sorts. To get an accurate grasp of all the runtimes, comparisons, and movements, I ran each sort with each array type 5 times and took an average for each of the 5 iterations. There was a total of 140 test cases. 

Taking all the different types of arrays into account (in order, reverse order, almost order, and random order) and each of the sorts’ times, Radix sort came out to be the best sort. It was quite obvious this was going to happen from the beginning because of its average case runtime of O(Nk). Merge sort came in a very close second, only being beat by 1 millisecond when taking the average of the run times. Selection Sort was very clearly the worst sort, as the highest it ranked in any of the array types was 6th. It was quite apparent that it would run poorly from the beginning because of its O(N^2) time complexity.

Selection Sort is very, very bad. For the 2 more randomized arrays, it took almost 5 seconds to sort while most of the other algorithms took less than 50 milliseconds. The only reason it didn’t come in last for all the array types is because one of the algorithms had a stack overflow error. There is really no reason to use the Selection Sort when there are other more efficient algorithms.

For both of the ordered sorts, the Insertion Sort came out on top, finishing in only 7 milliseconds. With the insertion sort, the time was very small, and the number of movements was rightfully 0. However, insertion sort didn’t do too well for the other categories, coming in second to last for both of the more randomized arrays. This is because its average case runtime is O(N^2). This sort also had the most comparisons and movements compared to the other sorting algorithms. With these results, it is apparent that insertion sort shouldn’t be readily used unless the structure is already sorted.

The Quick Sort performed average for the randomized arrays, as it came in 4th place for both of the randomized arrays. It was the only sorting algorithm that resulted in a stack overflow error. This was most likely because the recursions failed after a certain point of taking too many similar values. The stack overflow happened with any array with a size bigger than 20,000 elements. Although this problem could be fixed with a better implementation, it still shows that this is not a viable solution for sorted arrays because all the other sorting algorithms worked with this large of an array. Quick Sort isn’t bad for unsorted arrays, but definitely shouldn’t be used for arrays that are large and sorted.

Heap Sort ranked 5th for every sort so overall it is not a very good sorting algorithm. It was significantly slower than the Radix, Merge, Bucket, and even Quick Sort at times, taking over the double the time for some of the arrays. However, it is more consistent than both the Insertion and Quick sort, so it ranked higher in the average ranking. This sort can be used if a consistent sort is needed as it runs in similar time for all types of arrays.
    
The Bucket Sort is also a very good sort and was consistently within the first half of the rankings. It is overall better than when sorting randomized arrays, as it ranked 3rd for both of the more randomized arrays. The Sort, similar to the Radix Sort, is also a non-comparison sort. This sort actually had the least movements, on average, out of any of the other sorts. Overall, the Bucket Sort is a good and consistent sort, but not as good as the Merge and Radix Sorts.

Merge Sort was the second-best performing algorithm. It was only 1 millisecond slower than the Radix Sort. Despite Radix Sort being better overall, Merge Sort is better for data sets that are in order, compared to the Radix Sort. Merge also performed very well on the random arrays. Merge sort is a very good sorting algorithm overall, especially for large arrays.

As previously mentioned, Radix Sort is the best sort and is the most viable sorting algorithm for most arrays, especially for random arrays for which it ranked 1st. The disadvantages of Radix Sort are that it is based on the digits in the value, so it needs to be recoded for every type of object, and it takes more space than some other sorting algorithms. Despite this, the Radix sort should be used for any type of array because of its consistent efficiency. 

All things considered, both the Radix and Merge Sort are very good and reliable sorts. However, since the Radix Sort has Big O(Nk) and Merge Sort has O(NlogN), Radix Sort is better, and this can be seen when using arrays with a lot more elements. Selection Sort should never really be used when looking for efficiency. Insertion Sort should not be used either, despite its great performance with sorted arrays, because usually arrays won’t already be sorted when attempting to sort it. The Quick Sort can be used, but with caution because of its bad performance with large, sorted arrays. The Bucket and Heap Sorts are good backup sorts but should not be used if other more efficient sorts are available.

